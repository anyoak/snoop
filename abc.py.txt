
*Features:*
‚Ä¢ Account traffic usage with percentage
‚Ä¢ Registration date
‚Ä¢ Status monitoring
‚Ä¢ Real-time updates
‚Ä¢ Multi-account support

*Start by sending your account name or proxy string!*
        """
        
        await update.message.reply_text(
            welcome_message,
            parse_mode=ParseMode.MARKDOWN
        )

    async def handle_account_query(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle account query messages"""
        user_input = update.message.text.strip()
        chat_id = update.message.chat_id
        
        if not user_input:
            await update.message.reply_text("‚ùå Please provide an account name or proxy string.")
            return
        
        # Extract account names (support multiple lines)
        input_lines = user_input.split('\n')
        account_names = []
        
        for line in input_lines:
            line = line.strip()
            if line:
                account_name = self.extract_account_name(line)
                if account_name:
                    account_names.append(account_name)
        
        if not account_names:
            await update.message.reply_text("‚ùå No valid account names found in your input.")
            return
        
        # Send loading message with countdown
        loading_text = f"ü§ñ Syncing with ABC Cloud System...\nüìä Checking {len(account_names)} account(s)...(10s)"
        loading_message = await update.message.reply_text(loading_text)
        
        # Countdown animation
        for i in range(9, 0, -1):
            try:
                await context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=loading_message.message_id,
                    text=f"ü§ñ Syncing with ABC Cloud System...\nüìä Checking {len(account_names)} account(s)...({i}s)"
                )
                await asyncio.sleep(1)
            except:
                pass
        
        # Process all accounts
        results = self.run_account_check(account_names)
        
        # Send results
        success_count = 0
        for account_name, (message, keyboard) in results.items():
            if message and keyboard:
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=message,
                    reply_markup=keyboard,
                    parse_mode=ParseMode.MARKDOWN
                )
                success_count += 1
            else:
                error_msg = keyboard if keyboard else "‚ùå Unknown error"
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"üîç Account: {account_name}\n{error_msg}"
                )
        
        # Delete loading message
        try:
            await context.bot.delete_message(chat_id=chat_id, message_id=loading_message.message_id)
        except:
            pass
        
        # Send summary
        if success_count > 0:
            await context.bot.send_message(
                chat_id=chat_id,
                text=f"‚úÖ Successfully processed {success_count} out of {len(account_names)} account(s)"
            )

    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle inline keyboard callbacks"""
        query = update.callback_query
        await query.answer()

    async def broadcast_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle broadcast messages from admin"""
        if update.effective_user.id != ADMIN_ID:
            await update.message.reply_text("‚ùå Unauthorized access.")
            return
        
        if not context.args:
            await update.message.reply_text("‚ùå Usage: /broadcast <message>")
            return
        
        broadcast_text = " ".join(context.args)
        
        await update.message.reply_text(
            f"üì¢ Broadcast message prepared:\n\n{broadcast_text}\n\n"
            f"*This would be sent to all users.*",
            parse_mode=ParseMode.MARKDOWN
        )

    async def status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show bot status and session info"""
        global last_refresh_time
        
        status_message = f"""
ü§ñ *Bot Status Overview*

*Session Information:*
‚Ä¢ Last Refresh: {last_refresh_time.strftime('%Y-%m-%d %H:%M:%S') if last_refresh_time else 'Never'}
‚Ä¢ Next Refresh: {(last_refresh_time + timedelta(minutes=30)).strftime('%Y-%m-%d %H:%M:%S') if last_refresh_time else 'N/A'}
‚Ä¢ Browser Active: {'‚úÖ Yes' if self.driver else '‚ùå No'}

*Features:*
‚Ä¢ Multi-account support ‚úÖ
‚Ä¢ Auto-refresh every 30 minutes ‚úÖ
‚Ä¢ Percentage-based usage display ‚úÖ
‚Ä¢ Error handling and recovery ‚úÖ

*Usage:*
Send account names (one per line) for batch checking!
        """
        
        await update.message.reply_text(status_message, parse_mode=ParseMode.MARKDOWN)

    async def handle_media_broadcast(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle media broadcast from admin"""
        if update.effective_user.id != ADMIN_ID:
            return
        
        media_type = "Unknown"
        if update.message.photo:
            media_type = "Photo"
        elif update.message.video:
            media_type = "Video"
        elif update.message.sticker:
            media_type = "Sticker"
        elif update.message.document:
            media_type = "Document"
        elif update.message.animation:
            media_type = "GIF"
        
        await update.message.reply_text(f"‚úÖ {media_type} broadcast ready to send to all users.")

    def setup_handlers(self):
        """Setup Telegram bot handlers"""
        # Command handlers
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("broadcast", self.broadcast_command))
        self.application.add_handler(CommandHandler("status", self.status_command))
        
        # Message handlers
        self.application.add_handler(MessageHandler(
            filters.TEXT & ~filters.COMMAND, 
            self.handle_account_query
        ))
        
        # Media handlers for admin broadcast
        self.application.add_handler(MessageHandler(
            filters.PHOTO | filters.VIDEO | filters.STICKER | filters.DOCUMENT | filters.ANIMATION,
            self.handle_media_broadcast
        ))
        
        # Callback query handler
        self.application.add_handler(CallbackQueryHandler(self.handle_callback))

    def run_bot(self):
        """Run the Telegram bot"""
        self.application = Application.builder().token(BOT_TOKEN).build()
        self.setup_handlers()
        
        logger.info("ü§ñ Bot is running...")
        self.application.run_polling()

def main():
    """Main function"""
    print("üöÄ Starting ABC Proxy Account Monitor Bot...")
    print("üìù Make sure to replace 'YOUR_BOT_TOKEN_HERE' with your actual bot token")
    
    if BOT_TOKEN == "YOUR_BOT_TOKEN_HERE":
        print("‚ùå ERROR: Please set your bot token in the BOT_TOKEN variable")
        return
    
    # Create and run the bot
    bot = ABCProxyMonitorBot()
    bot.run_bot()

if __name__ == "__main__":
    main()